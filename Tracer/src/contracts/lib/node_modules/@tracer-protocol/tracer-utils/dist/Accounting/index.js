"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calcTradeExposure = exports.calcTotalMargin = exports.calcMinimumMargin = exports.calcNotionalValue = exports.calcWithdrawable = exports.calcBorrowed = exports.calcProfitableLiquidationPrice = exports.calcLiquidationPrice = exports.calcLeverage = void 0;
var RYAN_6 = 6;
var LIQUIDATION_GAS_COST = 25;
var calcLeverage = function (quote, base, price) {
    var margin = exports.calcTotalMargin(quote, base, price);
    if (margin <= 0)
        return -1;
    return exports.calcNotionalValue(base, price) / margin;
};
exports.calcLeverage = calcLeverage;
var calcLiquidationPrice = function (quote, base, price, maxLeverage) {
    var borrowed = exports.calcBorrowed(quote, base, price);
    if (borrowed > 0 || base < 0) {
        if (base > 0) {
            return (maxLeverage * (quote - RYAN_6 * LIQUIDATION_GAS_COST)) / (base - maxLeverage * base);
        }
        else if (base < 0) {
            return (-1 * (quote * maxLeverage - RYAN_6 * LIQUIDATION_GAS_COST * maxLeverage)) / (maxLeverage * base + base);
        }
    }
    return 0;
};
exports.calcLiquidationPrice = calcLiquidationPrice;
var calcProfitableLiquidationPrice = function (quote, base, price, maxLeverage) {
    var borrowed = exports.calcBorrowed(quote, base, price);
    if (borrowed > 0 || base < 0) {
        if (base > 0) {
            return (maxLeverage * (quote - (RYAN_6 * LIQUIDATION_GAS_COST - LIQUIDATION_GAS_COST))) / (base - maxLeverage * base);
        }
        else if (base < 0) {
            return (-1 * (quote * maxLeverage - (RYAN_6 * LIQUIDATION_GAS_COST - LIQUIDATION_GAS_COST) * maxLeverage)) / (maxLeverage * base + base);
        }
    }
    return 0;
};
exports.calcProfitableLiquidationPrice = calcProfitableLiquidationPrice;
var calcBorrowed = function (quote, base, price) {
    return Math.max(0, exports.calcNotionalValue(base, price) - exports.calcTotalMargin(quote, base, price));
};
exports.calcBorrowed = calcBorrowed;
var calcWithdrawable = function (quote, base, price, maxLeverage) {
    return exports.calcTotalMargin(quote, base, price) - (base !== 0 ? LIQUIDATION_GAS_COST * RYAN_6 + exports.calcNotionalValue(base, price) / maxLeverage : 0);
};
exports.calcWithdrawable = calcWithdrawable;
var calcNotionalValue = function (base, price) {
    return Math.abs(base) * price;
};
exports.calcNotionalValue = calcNotionalValue;
var calcMinimumMargin = function (quote, base, price, maxLeverage) {
    var borrowed = exports.calcBorrowed(quote, base, price);
    if (borrowed > 0 || base < 0) {
        return LIQUIDATION_GAS_COST * RYAN_6 + exports.calcNotionalValue(base, price) / maxLeverage;
    }
    else {
        return 0;
    }
};
exports.calcMinimumMargin = calcMinimumMargin;
var calcTotalMargin = function (quote, base, price) { var _a; return (_a = (quote + base * price)) !== null && _a !== void 0 ? _a : 0; };
exports.calcTotalMargin = calcTotalMargin;
var calcTradeExposure = function (quote, leverage, orders) {
    if (orders.length) {
        var exposure = 0, sumOfWeights = 0, totalUnits = 0;
        var buyingPower = quote * leverage;
        for (var _i = 0, orders_1 = orders; _i < orders_1.length; _i++) {
            var order = orders_1[_i];
            var amount = order.amount;
            var orderPrice = order.price;
            var r = buyingPower - amount * orderPrice;
            if (r >= 0) {
                totalUnits += orderPrice * amount;
                sumOfWeights += amount;
                exposure += amount * orderPrice;
                buyingPower -= amount * orderPrice;
            }
            else {
                if (buyingPower) {
                    totalUnits += buyingPower * orderPrice;
                    sumOfWeights += buyingPower;
                    exposure += buyingPower / orderPrice;
                }
                break;
            }
        }
        var expectedPrice = orders[0].price;
        var tradePrice = totalUnits ? totalUnits / sumOfWeights : expectedPrice;
        return {
            exposure: parseFloat(exposure.toFixed(10)),
            slippage: Math.abs((expectedPrice - tradePrice) / expectedPrice),
            tradePrice: tradePrice
        };
    }
    return {
        exposure: 0,
        slippage: 0,
        tradePrice: 0,
    };
};
exports.calcTradeExposure = calcTradeExposure;
//# sourceMappingURL=index.js.map